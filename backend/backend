#!/usr/bin/env python2

"""
Usage: %s [opts] SETTINGS-DOMAIN

Arguments:
SETTINGS-DOMAIN   SimpleDB domain to read settings from.

Options
-h STRING   Hostname for server. Defaults to empty.
-p INT      Port for server. Defaults to %i.

Runs the backend.
"""

import sys
import json
import time
import datetime
import traceback
import threading
import Queue
import boto
import wsgiref
import wsgiref.simple_server
import sdbutils
import queries
import backend_settings

default_port = 1500

class State:
  pass

def make_querier(settings):
  querier = queries.Querier(
    data_dom = sdbutils.get_maybenew_domain(sdb, settings.data_domain_name),
    description_page_size = settings.description_page_size,
    count_by_field_value_page_size = settings.count_by_field_value_page_size,
    count_by_year_page_size = settings.count_by_year_page_size,
    count_by_referencepoint_page_size = settings.count_by_referencepoint_page_size,
    num_initial_description_pages_to_cache = settings.num_initial_description_pages_to_cache,
    all_argument_numbers = settings.all_argument_numbers,
    fields_to_prime = settings.fields_to_prime
  )
  return querier

def clear_queue(queue):
  while True:
    try:
      x = queue.get_nowait()
    except Queue.Empty:
      return

def settings_watcher(exit_event, change_queue):
  settings = backend_settings.defaults
  running = True

  while running:
    change = State()

    print >> sys.stderr, "updating settings"
    new_settings = backend_settings.Settings(settings)
    backend_settings.update_settings_from_db(new_settings, backend_settings.defaults, settings_dom)
    change.settings = new_settings

    if new_settings.data_domain_name != settings.data_domain_name or new_settings.reset_always or new_settings.reset_next:
      if new_settings.reset_next:
        changed_settings = backend_settings.Settings()
        changed_settings.reset_next = False
        backend_settings.update_db_from_settings(settings_dom, changed_settings)
      print >> sys.stderr, "resetting"
      querier = make_querier(new_settings)
      print >> sys.stderr, "priming"
      querier.prime()
      print >> sys.stderr, "priming complete"
      change.querier = querier
    else:
      change.querier = None

    if change_queue.full():
      clear_queue(change_queue)
    change_queue.put(change)

    settings = new_settings
    running = not exit_event.wait(settings.settings_timeout)

def serve(hostname, port, sdb, settings_dom):
  state = State()
  state.settings = None
  state.querier = None

  change_queue = Queue.LifoQueue(1)
  exit_event = threading.Event()
  change_thread = threading.Thread(target=settings_watcher, args=(exit_event, change_queue))
  change_queue.daemon = True
  change_thread.start()

  def app(environ, start_response):
    print >> sys.stderr
    print >> sys.stderr, "request at %s" % (str(datetime.datetime.now()))

    need_update = state.settings is None or state.querier is None
    if not change_queue.empty() or need_update:
      try:
        change = change_queue.get(block=need_update)
        if change.settings is not None:
          print >> sys.stderr, "using new settings"
          state.settings = change.settings
        if change.querier is not None:
          print >> sys.stderr, "using new querier"
          state.querier = change.querier
      except Queue.Empty:
        # It's ok if there are no changes
        pass

    try:
      if environ['REQUEST_METHOD'] == 'POST':
        body = str(environ['wsgi.input'].read(int(environ['CONTENT_LENGTH'])))
        #print >> sys.stderr, "query: %s" % (body)
        query = json.loads(body)
      else:
        query = {}
      try:
        if state.querier is None:
          start_response("404 Not Found", [])
          return ["Could not handle query; server may be reloading data."]
        else:
          response = json.dumps(state.querier.handle(query))
          #print >> sys.stderr, "response: %s" % (response)
          start_response("200 OK", [("Content-type", "application/json"), ("Access-Control-Allow-Origin", "*")])
          return [response]
      except:
        print >> sys.stderr, "query response failed:"
        traceback.print_exc(file=sys.stderr)
    except:
      print >> sys.stderr, "couldn't read query from post:"
      traceback.print_exc(file=sys.stderr)

    # Fail if we haven't returned already
    start_response("404 Not Found", [])
    return ["Could not handle query."]

  try:
    httpd = wsgiref.simple_server.make_server(hostname, port, app)
    print >> sys.stderr, "serving"
    httpd.serve_forever()
  except:
    exit_event.set()
    raise

if __name__ == '__main__':
  import getopt

  try:
    opts, args = getopt.getopt(sys.argv[1:], "p:h:")
    if len(args) not in [1]:
      raise getopt.GetoptError("wrong number of positional arguments")
    opts = dict(opts)
  except getopt.GetoptError:
    print >> sys.stderr, __doc__.strip('\n\r') % (sys.argv[0], default_port)
    sys.exit(1)

  settings_dom_name = args[0]
  hostname = opts['-h'] if '-h' in opts else ""
  port = int(opts['-p']) if '-p' in opts else default_port

  print >> sys.stderr, "connecting to database"
  sdb = boto.connect_sdb()
  settings_dom = sdbutils.get_maybenew_domain(sdb, settings_dom_name)
  serve(hostname, port, sdb, settings_dom)
