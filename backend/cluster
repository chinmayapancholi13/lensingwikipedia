#!/usr/bin/env python2

"""
Usage: %s [opts] DATA-DOMAIN CLUSTER-DOMAIN [DATA-FILE]

Arguments:
DATA-DOMAIN     SimpleDB domain with the data to cluster.
CLUSTER-DOMAIN  SimpleDB domain for extra cluster information.
DATA-FILE       Local file to read data from. Ignored if -d is given. Standard
  input is used if neither are given.

Options:
  -i INT    Event ID offset.
  -t FLOAT  Distance threshold for choosing when to start new clusters.
  -D        Do dummy clustering; find cluster sizes and centres but don't
    upload to the database.

TODO

Clusters events and assigns the events to the clusters in the database. Each
clustering (assignment of events to clusters) has a name which is used as part
of the database field names. Each clustering has one or more detail levels, for
which different distance thresholds can be set here. The detail levels are
numbered 0 through whatever number of thresholds is given.

By default events are read from standard input or a file. When using this
method, make sure that the input data is exactly the same that was uploaded
(including order). Otherwise the wrong events may be assigned in the database.

Alternatively, events can be read from database. This method doesn't require
local data and removes the possibility of assigning to the wrong events, but it
requires much more overhead in bandwidth and database activity.

Note that since the clustering algorithm is greedy and the database does not
return events in any specific order, you may get different clustering results
depending on which method you use. Additionally the database may have lower
precision on the coordinates than local data, but this can be corrected by
using the -p option.
"""

import sys
import ioutils
import boto
import sdbutils

class Cluster:
  def __init__(self):
    self.centre = [0.0, 0.0]
    self.count = 0

def geo_cluster(events, threshold, assign_event_to_clusters):
  from math import atan2, sqrt, sin, cos, pi
  deg_to_rad = pi / 180.0

  def dist(a, b):
    # Vincenty formula, following the d3 implementation.
    dl = (b[0] - a[0]) * deg_to_rad
    p0, p1 = a[1] * deg_to_rad, b[1] * deg_to_rad
    sin_dl, cos_dl = sin(dl), cos(dl)
    sin_p0, cos_p0 = sin(p0), cos(p0)
    sin_p1, cos_p1 = sin(p1), cos(p1)
    return atan2(sqrt((cos_p1 * sin_dl)**2 + (cos_p0 * sin_p1 - sin_p0 * cos_p1 * cos_dl)**2), sin_p0 * sin_p1 + cos_p0 * cos_p1 * cos_dl)

  def updateAvgGeoPoint(avg, sample, count):
    """
    Update a running average of geo points, compensating for the fact that they
    may wrap around the antimeridian.
    """
    if count > 0:
      lon_changes = [0.0, 360.0, -360.0]
      lon = sample[0] + min(lon_changes, key=lambda dl: abs(sample[0] + dl - avg[0]))
      sample = (lon, sample[1])
      for i in range(2):
        avg[i] = (avg[i] * (count - 1) + sample[i]) / count
    else:
      for i in range(2):
        avg[i] = sample[i]
    if avg[0] > 180:
      avg[0] -= 360.0
    elif avg[0] < -1280:
      avg[0] += 360.0

  clusters = []
  event_clusters = {}

  for i, (event, points) in enumerate(events):
    print >> sys.stderr, "clustering event number %i" % (i)

    for point in points:
      closest = None
      closest_dist = float('inf')
      for cluster in clusters:
        cluster_dist = dist(point, cluster.centre)
        if cluster_dist < closest_dist:
          closest = cluster
          closest_dist = cluster_dist

      if closest_dist > threshold:
        closest = Cluster()
        clusters.append(closest)

      event_clusters.setdefault(event, set())
      if closest not in event_clusters[event]:
        event_clusters[event].add(closest)
        closest.count += 1
      updateAvgGeoPoint(closest.centre, point, closest.count)

  for event, clusters_for_event in event_clusters.iteritems():
    assign_event_to_clusters(event, clusters_for_event)

  return clusters

def iter_events_from_file(input, first_id):
  def get_points(event):
    def points_from(items):
      return set((float(i['longitude']), float(i['latitude'])) for i in items.itervalues() if 'latitude' in i and 'longitude' in i)
    points = points_from(event['wiki_info'])
    if 'locations' in event:
      points |= points_from(event['locations'])
    return points
  import json
  for id, line in enumerate(input):
    event = json.loads(line)
    points = get_points(event)
    if len(points) > 0:
      yield id, points

def update_clustering(data_dom, threshold, iter_events, do_dummy):
  def assign_event_to_clusters(event_id, clusters):
    point_vals = ["%f,%f" % (c.centre[0], c.centre[1]) for c in clusters]
    print >> sys.stderr, "event %i: %s" % (event_id, ' '.join(point_vals))
    if not do_dummy:
      item = data_dom.get_item(event_id)
      item['referencePoints'] = point_vals
      item.save()
  clusters = geo_cluster(iter_events, threshold, assign_event_to_clusters)
  for i, cluster in enumerate(clusters):
    print >> sys.stderr, "cluster %i: %f,%f %i" % (i, cluster.centre[0], cluster.centre[1], cluster.count)

if __name__ == '__main__':
  import getopt

  try:
    opts, args = getopt.getopt(sys.argv[1:], "i:t:D")
    if len(args) not in [1, 2]:
      raise getopt.GetoptError("wrong number of positional arguments")
    opts = dict(opts)
  except getopt.GetoptError:
    print >> sys.stderr, __doc__.strip('\n\r') % (sys.argv[0])
    sys.exit(1)

  data_domain_name = args[0]
  input_path = args[1] if len(args) > 1 else None
  threshold = float(opts['-t']) if '-t' in opts else 0.25
  first_id = int(opts['-i']) if '-i' in opts else 0
  do_dummy = '-D' in opts

  sdb = boto.connect_sdb()
  data_dom = sdbutils.get_maybenew_domain(sdb, data_domain_name, make_new=False)

  if input_path is not None:
    with open(input_path) as input:
      iter_events = iter_events_from_file(input, first_id)
      update_clustering(data_dom, threshold, iter_events, do_dummy)
  else:
    iter_events = iter_events_from_file(sys.stdin, first_id)
    update_clustering(data_dom, threshold, iter_events, do_dummy)
